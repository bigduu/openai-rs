//! Module responsible for managing and executing the chain of processors.

use crate::event::InternalStreamEvent;
use crate::processor::Processor;
use anyhow::Result;
use std::collections::VecDeque;

// Placeholder content
pub struct ProcessorChain {
    processors: Vec<Box<dyn Processor>>,
}

impl ProcessorChain {
    // Placeholder method
    pub fn new(processors: Vec<Box<dyn Processor>>) -> Self {
        ProcessorChain { processors }
    }

    // Placeholder execution method
    pub async fn execute(
        &self,
        initial_events: Vec<InternalStreamEvent>,
    ) -> Result<Vec<InternalStreamEvent>> {
        let mut event_queue: VecDeque<InternalStreamEvent> = initial_events.into();
        let mut processed_events = Vec::new(); // Or maybe this returns a stream? TBD.

        // Simplified loop - real implementation needs careful handling of the output_queue
        // and potentially parallel processing or different execution strategies.
        while let Some(mut event) = event_queue.pop_front() {
            let mut output_queue = VecDeque::new();
            for processor in &self.processors {
                // Basic error handling - might need more sophisticated strategy
                processor.process(&mut event, &mut output_queue).await?;
                // Add newly generated events to the front for immediate processing? Or back? Design decision.
                // For now, let's assume they get added to the main queue to be processed after current batch.
            }
            // Add events generated by processors to the main queue
            event_queue.extend(output_queue);
            // Assume the (potentially modified) event is kept
            processed_events.push(event);
        }

        Ok(processed_events)
    }
}
